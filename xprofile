#!/usr/bin/env python2
import os
import sys

from re import compile
from hashlib import md5
from subprocess import Popen, PIPE
from argparse import ArgumentParser

try:
    from ConfigParser import ConfigParser
except ImportError:
    from configparser import ConfigParser


VERSION = '1.0.1'

XRANDR  = '/usr/bin/xrandr'
RCFILE = os.path.expanduser('~/.xprofilerc')
DEFAULT_SECTION = '''\
[DEFAULT]
display = {display}
args = --auto
'''

RE_EDID = compile(r'^\s*([a-f0-9]{32})$')
RE_CONNECTED = compile(r'^(\w+) connected.*$')
RE_XRANDR_NOISE   = compile(r'^(Screen|\t|  |$)')
RE_XRANDR_DISPLAY = compile(r'^(?P<name>[^\s]+) (?P<status>disconnected|connected|unknown connection) ?(?P<geometry>(?P<width>[0-9]+)x(?P<height>[0-9]+)\+(?P<x>[0-9]+)\+(?P<y>[0-9]+))? \((?P<modeid>[a-z]+) (?P<rotation>[a-z]+).*\)')


def list_all_profiles(args, config):
    '''
    List all known profiles from ~/.xprofilerc
    '''
    sections = config.sections()
    if len(sections) > 0:
        print('\n'.join(config.sections()));

    return 0


def get_current_edid(args, config):
    '''
    Print the current EDID to stdout
    '''
    print(_get_current_edid())


def activate_profile(args, config):
    '''
    Either activate the given profile, or if no profile is given
    automatically select a known profile by comparing the hashes of
    EDID's
    '''
    if not args.profile:
        current_edid = _get_current_edid()
        current_profile = None

        for profile in config.sections():
            if config.get(profile, 'edid') == current_edid:
                print_err('Detected profile {}'.format(profile))
                current_profile = profile

        if not current_profile:
            print_err('No known profile found for EDID: {}'.format(current_edid))
            xrandr_args = [XRANDR, config.get('DEFAULT', 'args')]
        else:
            xrandr_args = [XRANDR] + config.get(current_profile, 'args').split()

    elif not config.has_section(args.profile):
        print_err('Profile {} not found'.format(args.profile))
        return 1
    else:
        xrandr_args = [XRANDR] + config.get(args.profile, 'args').split()

    print(xrandr_args)
    _call_xrandr(xrandr_args)

    return 0


def create_profile(args, config):
    '''
    Generate a new .ini style configuration section for the current EDID.
    Print the result to stdout, so the user can include it in his ~/.xprofilerc
    '''
    current_edid = _get_current_edid()

    for profile in config.sections():
        if config.get(profile, 'edid') == current_edid:
            print_err('A profile already exists for EDID `{}` with the name `{}`'.format(current_edid, profile))
            return 1

    config.add_section(args.profile)
    config.set(args.profile, 'name', '{}\'s xrandr profile'.format(args.profile))
    config.set(args.profile, 'edid', current_edid)
    config.set(args.profile, 'args', ' '.join(_get_current_xrandr_config()))
    config.write(open(RCFILE, 'w'))

    print('Profile created in {}'.format(RCFILE))

    return 0


def _get_current_edid():
    '''
    Get a md5 hash of all EDID of all currently connected screens
    '''
    output = _call_xrandr([XRANDR, '--verbose'])
    md5sum = md5()

    for line in output.split('\n'):
        if RE_EDID.match(line):
            md5sum.update(line.strip())
    return md5sum.hexdigest()


def _parse_xrandr_output():
    '''
    Parse every `display` line from xrandr output and ignore the rest
    '''
    output = _call_xrandr([XRANDR])
    displays = []

    for line in output.split('\n'):
        parts = RE_XRANDR_DISPLAY.match(line)

        if not parts:
            continue

        display = {}
        display['name'] = parts.group('name')
        display['status'] = parts.group('status')
        display['connected'] = parts.group('status') == 'connected'
        display['rotation'] = parts.group('rotation')
        # TODO: determine display['primary'] = True|False

        if parts.group('geometry'):
            display['geometry'] = {}
            display['geometry']['dimension'] = '%sx%s' % (parts.group('width'), parts.group('height'))
            display['geometry']['offset'] = '%sx%s' % (parts.group('x'), parts.group('y'))
        else:
            display['geometry'] = None

        display['active'] = isinstance(display['geometry'], dict)

        displays.append(display)

    return displays


def _get_current_xrandr_config():
    '''
    Loop through all active displays and create an xrandr compatible
    option list.
    '''
    line = []
    for display in _parse_xrandr_output():
        line += ['--output', display['name']]
        if not display['active']:
            line += ['--off']
        else:
            line += [
                '--mode',   display['geometry']['dimension'],
                '--pos',    display['geometry']['offset'],
                '--rotate', display['rotation']
            ]
    return line


def _call_xrandr(args, display=None):
    '''
    Make a call to the xrandr binary in a subprocess
    '''
    current_env = os.environ.copy()

    if display:
        current_env['DISPLAY'] = display

    process = Popen(args, env=current_env, stdout=PIPE)
    stdout, stderr = process.communicate()
    status = process.wait()

    if status != 0:
        print_err('xrandr non-zero exit code detected: {}'.format(status))

    return stdout


def print_err(*args):
    '''
    Print to stderr
    '''
    sys.stderr.write(' '.join(map(str,args)) + '\n')


def parse_commandline_arguments(args=None):
    '''
    Add several subcommands, each with their own options and arguments.
    '''
    parser = ArgumentParser(description='Manage xrandr profiles')
    parser.add_argument('--version', action='version', version='%(prog)s ' + VERSION)
    subparsers = parser.add_subparsers(help="The following subcommands are available")

    parser_a = subparsers.add_parser('list', help="List all available xrandr profiles")
    parser_a.set_defaults(func=list_all_profiles)

    parser_b = subparsers.add_parser('current-edid', help="Get the current profile edid hash")
    parser_b.set_defaults(func=get_current_edid)

    parser_c = subparsers.add_parser('auto', help="Automatically select the profile")
    parser_c.set_defaults(func=activate_profile, profile=None)

    parser_d = subparsers.add_parser('activate', help="Activate a known profile")
    parser_d.set_defaults(func=activate_profile)
    parser_d.add_argument('profile', help='The profile to select')

    parser_e = subparsers.add_parser('create', help="Create a new profile for the current EDID")
    parser_e.set_defaults(func=create_profile)
    parser_e.add_argument('profile', help='The name for the new profile')

    return parser.parse_args()


def main(args=None):
    '''
    Main entrypoint for this application
    '''
    args = parse_commandline_arguments(args)

    if not os.path.exists(RCFILE):
        with open(RCFILE, 'w') as file:
            file.write(DEFAULT_SECTION.format(display=os.environ['DISPLAY']))

    config = ConfigParser()
    config.read(RCFILE)

    return args.func(args, config=config)


if '__main__' == __name__:
    sys.exit(main())
